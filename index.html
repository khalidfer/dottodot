<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dot-to-Dot Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a better look */
        /* MODIFIED: Used unique class .d2d-body */
        .d2d-body {
            font-family: 'Inter', sans-serif;
        }
        /* MODIFIED: Used unique class .d2d-canvas */
        .d2d-canvas {
            cursor: crosshair;
            background-color: #ffffff;
            /* Ensure canvas doesn't shrink smaller than its set size */
            min-width: var(--canvas-width, auto);
            min-height: var(--canvas-height, auto);
        }
        .tool-radio:checked + label {
            background-color: #3b82f6; /* bg-blue-600 */
            color: #ffffff; /* text-white */
            border-color: #3b82f6; /* border-blue-600 */
        }
        .tool-radio:disabled + label {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Style for the eraser cursor */
        .eraser-cursor {
            cursor: none; /* Hide default cursor */
        }
        /* Styles for Pan Tool */
        .pan-cursor {
            cursor: grab;
        }
        .panning-cursor {
            cursor: grabbing;
        }
        /* Ensure the container itself can scroll */
        #canvas-container {
            max-width: 100%;
            max-height: 85vh; /* Increased from 80vh to 85vh */
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script>
        // Configuration for Tailwind dark mode
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
</head>
<!-- MODIFIED: Added .d2d-body class, REMOVED p-4 -->
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col items-center d2d-body">

    <!-- Removed max-w-7xl to allow full width, REMOVED px-4 lg:px-8 -->
    <div class="w-full mx-auto">
        
        <!-- REMOVED Header Block -->
        
        <!-- MODIFIED: Switched to CSS Grid, changed lg: to md: -->
        <main class="grid grid-cols-1 md:grid-cols-4 gap-4 mt-4">

            
            <!-- MODIFIED: Switched to md:col-span-1 -->
            <aside class="w-full md:col-span-1 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4 border-b border-gray-300 dark:border-gray-600 pb-2">Controls</h2>
                
                
                <div class="mb-4">
                    <label for="imageLoader" class="block text-sm font-medium mb-2">1. Upload Image(s)</label>
                    <input type="file" id="imageLoader" accept="image/*" multiple class="block w-full text-sm text-gray-500 dark:text-gray-400
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-lg file:border-0
                        file:text-sm file:font-semibold
                        file:bg-blue-50 dark:file:bg-blue-900
                        file:text-blue-700 dark:file:text-blue-300
                        hover:file:bg-blue-100 dark:hover:file:bg-blue-800
                        cursor-pointer">
                </div>

                
                <div class="mb-4">
                    <label for="imageSelector" class="block text-sm font-medium mb-2">2. Select Active Image</label>
                    <select id="imageSelector" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-900 dark:text-gray-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2.5" disabled>
                        <option value="">Upload images first</option>
                    </select>
                </div>

                
                <div class="mb-4">
                    <span class="block text-sm font-medium mb-2">3. Select Tool</span>
                    <div class="grid grid-cols-2 gap-2">
                        
                        <div>
                            <input type="radio" name="tool" id="tool-add" value="add" class="sr-only tool-radio" checked disabled>
                            <label for="tool-add" class="flex flex-col items-center justify-center p-2 border-2 border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer text-center text-sm font-medium transition-colors">
                                
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                Add Dots
                            </label>
                        </div>
                        
                        <div>
                            <input type="radio" name="tool" id="tool-erase-image" value="erase-image" class="sr-only tool-radio" disabled>
                            <label for="tool-erase-image" class="flex flex-col items-center justify-center p-2 border-2 border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer text-center text-sm font-medium transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                </svg>
                                Erase Image
                            </label>
                        </div>
                         
                        <div>
                            <input type="radio" name="tool" id="tool-erase-dots" value="erase-dots" class="sr-only tool-radio" disabled>
                            <label for="tool-erase-dots" class="flex flex-col items-center justify-center p-2 border-2 border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer text-center text-sm font-medium transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2A9 9 0 111 12a9 9 0 0118 0z" />
                                </svg>
                                Erase Dots
                            </label>
                        </div>
                        <!-- NEW Pan Tool Button - CORRECTED SVG -->
                        <div>
                            <input type="radio" name="tool" id="tool-pan" value="pan" class="sr-only tool-radio" disabled>
                            <label for="tool-pan" class="flex flex-col items-center justify-center p-2 border-2 border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer text-center text-sm font-medium transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M7 11.5l5 5 5-5m-10-2l5-5 5 5" />
                                </svg>
                                Pan
                            </label>
                        </div>
                    </div>
                </div>

                
                <div class="mb-4 space-y-3">
                    <div>
                        <label for="dotSize" class="block text-sm font-medium">Dot Size (px)</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="dotSize" min="1" max="20" value="3" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span id="dotSizeValue" class="text-sm font-mono w-6 text-right">3</span>
                        </div>
                    </div>
                    
                    <div>
                        <label for="lineWidth" class="block text-sm font-medium">Line Width (px)</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="lineWidth" min="0" max="10" value="1" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span id="lineWidthValue" class="text-sm font-mono w-6 text-right">1</span>
                        </div>
                    </div>
                    
                    <div>
                        <label for="fontSize" class="block text-sm font-medium">Number Size (px)</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="fontSize" min="8" max="32" value="12" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span id="fontSizeValue" class="text-sm font-mono w-6 text-right">12</span>
                        </div>
                    </div>
                    <div>
                        <label for="eraseDotsRadius" class="block text-sm font-medium">Erase Dots Radius (px)</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="eraseDotsRadius" min="5" max="50" value="20" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span id="eraseDotsRadiusValue" class="text-sm font-mono w-6 text-right">20</span>
                        </div>
                    </div>
                    <div>
                        <label for="eraseImageRadius" class="block text-sm font-medium">Erase Image Radius (px)</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="eraseImageRadius" min="5" max="50" value="20" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span id="eraseImageRadiusValue" class="text-sm font-mono w-6 text-right">20</span>
                        </div>
                    </div>
                    <div>
                        <label for="spacingSlider" class="block text-sm font-medium">Fixed Spacing (px)</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="spacingSlider" min="0" max="100" value="0" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span id="spacingValue" class="text-sm font-mono w-6 text-right">0</span>
                        </div>
                    </div>

                    
                    <div class="grid grid-cols-2 gap-2 pt-2">
                        <div>
                            <label for="dotColorPicker" class="block text-sm font-medium mb-1">Dot Color</label>
                            <input type="color" id="dotColorPicker" value="#000000" class="w-full h-8 border border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer">
                        </div>
                        <div>
                            <label for="lineColorPicker" class="block text-sm font-medium mb-1">Line Color</label>
                            <input type="color" id="lineColorPicker" value="#000000" class="w-full h-8 border border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer">
                        </div>
                    </div>
                </div>

                
                <div class="mb-4 space-y-2">
                    <label class="block text-sm font-medium">Zoom</label>
                    <div class="flex items-center gap-2">
                        <button id="zoomOutButton" class="w-10 h-10 flex-shrink-0 flex items-center justify-center bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg font-bold text-lg disabled:opacity-50" disabled>-</button>
                        <span id="zoomLevelDisplay" class="w-full text-center font-mono text-sm">100%</span>
                        <button id="zoomInButton" class="w-10 h-10 flex-shrink-0 flex items-center justify-center bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg font-bold text-lg disabled:opacity-50" disabled>+</button>
                    </div>
                    <button id="zoomResetButton" class="w-full py-2 px-4 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-sm font-semibold rounded-lg shadow transition-colors disabled:opacity-50" disabled>Reset Zoom</button>
                </div>

                
                <div class="space-y-2">
                    <button id="undoButton" class="w-full py-2 px-4 bg-yellow-500 hover:bg-yellow-600 text-white font-semibold rounded-lg shadow transition-colors disabled:opacity-50" disabled>Undo Last Dot</button>
                    <button id="clearButton" class="w-full py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg shadow transition-colors disabled:opacity-50" disabled>Clear All (This Image)</button>
                    <button id="toggleImageButton" class="w-full py-2 px-4 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow transition-colors disabled:opacity-50" disabled>Toggle Image</button>
                </div>

                
                <div class="mt-6 border-t border-gray-300 dark:border-gray-600 pt-4">
                    <button id="downloadButton" class="w-full py-3 px-4 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-lg transition-colors disabled:opacity-50" disabled>
                        Download as PNG
                    </button>
                    <!-- NEW "Download All" Button -->
                    <button id="downloadAllButton" class="w-full mt-2 py-3 px-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-lg transition-colors disabled:opacity-50" disabled>
                        Download All as PNGs
                    </button>
                </div>

            </aside>

            
            <!-- MODIFIED: Switched to md:col-span-3 -->
            <div class="w-full md:col-span-3">
                <!-- MODIFIED: Removed lg:h-auto lg:aspect-video -->
                <div id="canvas-container" class="relative w-full h-[70vh] bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-auto flex items-center justify-center">
                    <!-- MODIFIED: Added .d2d-canvas class -->
                    <canvas id="dotCanvas" class="d2d-canvas"></canvas>
                    <div id="eraser-preview" class="absolute rounded-full border-2 border-red-500 pointer-events-none hidden" style="mix-blend-mode: difference;"></div>
                    <div id="placeholder-text" class="absolute text-gray-400 dark:text-gray-500 text-center p-8">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                        </svg>
                        <h3 class="text-xl font-semibold">Upload an image to start</h3>
                        <p class="text-sm">Your image will appear here. Then, select a tool and click on the image to place dots.</p>
                    </div>
                </div>
            </div>

        </main>
    </div>

    
    <div id="confirmModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 max-w-sm w-full">
            <h3 id="modalTitle" class="text-lg font-semibold mb-4">Confirm Action</h3>
            <p id="modalMessage" class="text-sm text-gray-700 dark:text-gray-300 mb-6">Are you sure?</p>
            <div class="flex justify-end gap-3">
                <button id="modalCancel" class="py-2 px-4 bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100 font-semibold rounded-lg shadow transition-colors">
                    Cancel
                </button>
                <button id="modalConfirm" class="py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg shadow transition-colors">
                    Yes, Confirm
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('dotCanvas');
            const ctx = canvas.getContext('2d');
            const imageLoader = document.getElementById('imageLoader');
            
            // Controls
            const toolRadios = document.querySelectorAll('input[name="tool"]');
            const imageSelector = document.getElementById('imageSelector');
            const dotSizeSlider = document.getElementById('dotSize');
            const lineWidthSlider = document.getElementById('lineWidth'); 
            const fontSizeSlider = document.getElementById('fontSize'); 
            const dotSizeValue = document.getElementById('dotSizeValue');
            const lineWidthValue = document.getElementById('lineWidthValue'); 
            const fontSizeValue = document.getElementById('fontSizeValue'); 
            const eraseDotsRadiusSlider = document.getElementById('eraseDotsRadius');
            const eraseDotsRadiusValue = document.getElementById('eraseDotsRadiusValue');
            const eraseImageRadiusSlider = document.getElementById('eraseImageRadius');
            const eraseImageRadiusValue = document.getElementById('eraseImageRadiusValue');
            const dotColorPicker = document.getElementById('dotColorPicker');
            const lineColorPicker = document.getElementById('lineColorPicker');
            const spacingSlider = document.getElementById('spacingSlider');
            const spacingValue = document.getElementById('spacingValue');
            
            // Buttons
            const undoButton = document.getElementById('undoButton');
            const clearButton = document.getElementById('clearButton');
            const toggleImageButton = document.getElementById('toggleImageButton');
            const downloadButton = document.getElementById('downloadButton');
            const downloadAllButton = document.getElementById('downloadAllButton'); // Get the new button
            
            // Zoom Controls
            const zoomInButton = document.getElementById('zoomInButton');
            const zoomOutButton = document.getElementById('zoomOutButton');
            const zoomResetButton = document.getElementById('zoomResetButton');
            const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');

            // Canvas Container
            const canvasContainer = document.getElementById('canvas-container');
            const placeholderText = document.getElementById('placeholder-text');
            const eraserPreview = document.getElementById('eraser-preview');

            // Modal Elements
            const confirmModal = document.getElementById('confirmModal');
            const modalMessage = document.getElementById('modalMessage');
            const modalCancel = document.getElementById('modalCancel');
            const modalConfirm = document.getElementById('modalConfirm');
            const modalTitle = document.getElementById('modalTitle');

            // State
            let allDots = []; // Array of arrays: [[...img1dots], [...img2dots]]
            let originalBackgroundImages = []; // Array of Image objects
            let currentBackgroundImages = []; // Array of Canvas elements (for erasing)
            let activeImageIndex = -1; // Index for the currently active image

            let showImage = true;
            let currentTool = 'add'; // Default tool
            let dotSize = parseInt(dotSizeSlider.value, 10);
            let lineWidth = parseInt(lineWidthSlider.value, 10);
            let fontSize = parseInt(fontSizeSlider.value, 10);
            let eraseDotsRadius = parseInt(eraseDotsRadiusSlider.value, 10);
            let eraseImageRadius = parseInt(eraseImageRadiusSlider.value, 10);
            let dotColor = dotColorPicker.value;
            let lineColor = lineColorPicker.value;
            let dotSpacing = parseInt(spacingSlider.value, 10);
            let isDrawing = false; // For continuous erasing
            // NEW Pan State
            let isPanning = false;
            let lastPanX = 0;
            let lastPanY = 0;

            // Zoom State
            let zoomLevel = 1.0;
            const minZoom = 0.2;
            const maxZoom = 5.0;
            const zoomStep = 0.1;

            // --- Helper Functions ---

            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (evt.clientX - rect.left) * scaleX,
                    y: (evt.clientY - rect.top) * scaleY
                };
            }

            // Switches the active image on the canvas
            function switchToImage(index) {
                if (index < 0 || index >= originalBackgroundImages.length) {
                    // Handle case where all images might have been removed or no images loaded
                    activeImageIndex = -1;
                    imageSelector.value = '';
                    canvas.width = 0; // Clear canvas size
                    canvas.height = 0;
                    placeholderText.classList.remove('hidden');
                    disableControls(); // Disable controls if no image
                    draw(); // Clear display
                    return;
                }

                activeImageIndex = index;
                imageSelector.value = index;

                const activeImage = originalBackgroundImages[activeImageIndex];
                
                // Set canvas physical dimensions
                canvas.width = activeImage.width;
                canvas.height = activeImage.height;
                
                // Reset zoom and apply it (which sets style width/height)
                zoomLevel = 1.0;
                updateZoom();

                enableControls(); // Re-enable controls as an image is now active
                draw();
            }

            function draw() {
                if (activeImageIndex === -1) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height); // Ensure canvas is clear if no image
                    return;
                }

                const activeBg = currentBackgroundImages[activeImageIndex];
                const activeDots = allDots[activeImageIndex];
                
                if (!activeBg) return; // Exit if background isn't ready

                // Clear canvas fully to redraw everything
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background image if applicable
                if (showImage && activeBg) {
                    ctx.drawImage(activeBg, 0, 0);
                }

                // Draw lines
                if (lineWidth > 0 && activeDots.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(activeDots[0].x, activeDots[0].y);
                    for (let i = 1; i < activeDots.length; i++) {
                        ctx.lineTo(activeDots[i].x, activeDots[i].y);
                    }
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = lineWidth;
                    ctx.stroke();
                }

                // Draw dots and numbers
                ctx.font = `${fontSize}px Arial`;
                // ctx.textAlign = 'center'; // No longer default center
                ctx.textBaseline = 'middle';

                activeDots.forEach(dot => {
                    // Draw dot
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, dotSize, 0, 2 * Math.PI);
                    ctx.fillStyle = '#FFFFFF'; // Always fill dot with white
                    ctx.fill();
                    ctx.strokeStyle = dotColor; // Use selected dot color for outline
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Draw number
                    ctx.fillStyle = dotColor; // Use selected dot color for number
                    ctx.textAlign = 'right'; // Align text to the right
                    // Offset number to the left of the dot
                    ctx.fillText(dot.number, dot.x - dotSize - 5, dot.y); // 5px gap
                });
            }

            function updateZoom() {
                if (activeImageIndex === -1 || !originalBackgroundImages[activeImageIndex]) {
                     // No active image, reset zoom display
                    zoomLevel = 1.0;
                    zoomLevelDisplay.textContent = '100%';
                    canvas.style.width = 'auto';
                    canvas.style.height = 'auto';
                    // CSS variables for min-width/height
                    canvas.style.setProperty('--canvas-width', 'auto');
                    canvas.style.setProperty('--canvas-height', 'auto');
                    return;
                }

                const activeImg = originalBackgroundImages[activeImageIndex];

                // Clamp zoom level
                zoomLevel = Math.max(minZoom, Math.min(maxZoom, zoomLevel));
                
                // Update display
                zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;

                const displayWidth = activeImg.width * zoomLevel;
                const displayHeight = activeImg.height * zoomLevel;

                // Update canvas display size
                canvas.style.width = `${displayWidth}px`;
                canvas.style.height = `${displayHeight}px`;

                // Update CSS variables for min-width/height
                canvas.style.setProperty('--canvas-width', `${displayWidth}px`);
                canvas.style.setProperty('--canvas-height', `${displayHeight}px`);

                
                // Update button states
                zoomInButton.disabled = zoomLevel >= maxZoom;
                zoomOutButton.disabled = zoomLevel <= minZoom;
                zoomResetButton.disabled = zoomLevel === 1.0;
            }

            function enableControls() {
                placeholderText.classList.add('hidden');
                toolRadios.forEach(radio => radio.disabled = false);
                toggleImageButton.disabled = false;
                downloadButton.disabled = false;
                downloadAllButton.disabled = originalBackgroundImages.length === 0; // Enable new button
                zoomInButton.disabled = false;
                zoomOutButton.disabled = false;
                zoomResetButton.disabled = false;
                imageSelector.disabled = originalBackgroundImages.length <= 1;
                updateButtonStates();
                updateZoom(); 
            }

            function disableControls() {
                toolRadios.forEach(radio => radio.disabled = true);
                undoButton.disabled = true;
                clearButton.disabled = true;
                toggleImageButton.disabled = true;
                downloadButton.disabled = true;
                downloadAllButton.disabled = true; // Disable new button
                zoomInButton.disabled = true;
                zoomOutButton.disabled = true;
                zoomResetButton.disabled = true;
                imageSelector.disabled = true;
                imageSelector.innerHTML = '<option value="">Upload images first</option>';
            }

            function updateButtonStates() {
                if (activeImageIndex === -1) {
                    undoButton.disabled = true;
                    clearButton.disabled = true;
                    return;
                }
                const activeDots = allDots[activeImageIndex];
                undoButton.disabled = activeDots.length === 0;
                clearButton.disabled = activeDots.length === 0;
            }

            function renumberDots() {
                if (activeImageIndex === -1) return;
                const activeDots = allDots[activeImageIndex];
                activeDots.forEach((dot, index) => {
                    dot.number = index + 1;
                });
            }

            // Function to handle erasing dots
            function eraseDotsAtPosition(e) {
                if (activeImageIndex === -1) return;
                const activeDots = allDots[activeImageIndex];
                const pos = getMousePos(e);
                let dotsRemoved = false;

                for (let i = activeDots.length - 1; i >= 0; i--) {
                    const dot = activeDots[i];
                    const distance = Math.sqrt(Math.pow(pos.x - dot.x, 2) + Math.pow(pos.y - dot.y, 2));
                    if (distance < eraseDotsRadius) {
                        activeDots.splice(i, 1);
                        dotsRemoved = true;
                    }
                }

                if (dotsRemoved) {
                    renumberDots();
                    updateButtonStates();
                }
            }

            // Function to erase parts of the image content
            function eraseCanvasContentAtPosition(e) {
                if (activeImageIndex === -1 || !currentBackgroundImages[activeImageIndex]) return;

                const activeBg = currentBackgroundImages[activeImageIndex];
                const pos = getMousePos(e);
                const tempCtx = activeBg.getContext('2d');
                
                tempCtx.save();
                tempCtx.beginPath();
                tempCtx.arc(pos.x, pos.y, eraseImageRadius, 0, 2 * Math.PI);
                tempCtx.clip();
                tempCtx.clearRect(0, 0, activeBg.width, activeBg.height);
                tempCtx.restore();
            }


            // --- Event Listeners ---

            // Image Loader
            imageLoader.addEventListener('change', (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) {
                    disableControls();
                    return;
                }
                
                originalBackgroundImages = new Array(files.length);
                currentBackgroundImages = new Array(files.length);
                allDots = new Array(files.length).fill(null).map(() => []); // Initialize with empty arrays
                
                imageSelector.innerHTML = ''; 
                placeholderText.classList.remove('hidden'); 
                
                let filesToLoad = files.length;
                let loadedCount = 0;

                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const image = new Image();
                        image.onload = () => {
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = image.width;
                            tempCanvas.height = image.height;
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCtx.drawImage(image, 0, 0);
                            
                            originalBackgroundImages[index] = image;
                            currentBackgroundImages[index] = tempCanvas;
                            
                            imageSelector.add(new Option(file.name, index));
                            
                            loadedCount++;
                            if (loadedCount === filesToLoad) {
                                enableControls();
                                switchToImage(0); // Switch to the first loaded image
                            }
                        }
                        image.onerror = () => {
                            console.error(`Failed to load image: ${file.name}`);
                            loadedCount++;
                            if (loadedCount === filesToLoad) {
                                // If some failed, still try to load first successful one
                                const firstLoadedIndex = originalBackgroundImages.findIndex(img => img);
                                if (firstLoadedIndex !== -1) {
                                    enableControls();
                                    switchToImage(firstLoadedIndex);
                                } else {
                                    disableControls(); // No images loaded successfully
                                }
                            }
                        }
                        image.src = event.target.result;
                    }
                    reader.onerror = () => {
                         console.error(`Failed to read file: ${file.name}`);
                         loadedCount++; // Count as processed, even if failed
                         if (loadedCount === filesToLoad) {
                             const firstLoadedIndex = originalBackgroundImages.findIndex(img => img);
                             if (firstLoadedIndex !== -1) {
                                 enableControls();
                                 switchToImage(firstLoadedIndex);
                             } else {
                                 disableControls();
                             }
                         }
                    }
                    reader.readAsDataURL(file);
                });
            });

            // Image Selector
            imageSelector.addEventListener('change', (e) => {
                const newIndex = parseInt(e.target.value, 10);
                if (!isNaN(newIndex)) {
                    switchToImage(newIndex);
                }
            });

            // Tool Selection
            toolRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    currentTool = e.target.value;
                    // Reset container cursors
                    canvasContainer.classList.remove('pan-cursor', 'panning-cursor');
                    canvas.classList.remove('eraser-cursor');
                    canvas.style.cursor = 'crosshair'; // Default for add

                    if (currentTool.startsWith('erase')) {
                        canvas.classList.add('eraser-cursor');
                        eraserPreview.classList.remove('hidden');
                    } else if (currentTool === 'pan') {
                        canvasContainer.classList.add('pan-cursor');
                        canvas.style.cursor = 'default'; // No crosshair for pan
                        eraserPreview.classList.add('hidden');
                    } else {
                        // 'add' tool
                        canvas.style.cursor = 'crosshair';
                        eraserPreview.classList.add('hidden');
                    }
                });
            });

            // Canvas Click (for adding dots)
            canvas.addEventListener('click', (e) => {
                if (activeImageIndex === -1 || currentTool !== 'add') return;
                
                const pos = getMousePos(e);
                const activeDots = allDots[activeImageIndex];

                let newX = pos.x;
                let newY = pos.y;

                if (dotSpacing > 0 && activeDots.length > 0) {
                    const lastDot = activeDots[activeDots.length - 1];
                    const dx = pos.x - lastDot.x;
                    const dy = pos.y - lastDot.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) { // Avoid division by zero
                        const normX = dx / distance;
                        const normY = dy / distance;
                        newX = lastDot.x + normX * dotSpacing;
                        newY = lastDot.y + normY * dotSpacing;
                    } else {
                        return; // If click is on the last dot, do nothing
                    }
                }

                activeDots.push({ x: newX, y: newY, number: activeDots.length + 1 });
                updateButtonStates();
                draw();
            });

            // Canvas Mouse Events for Erasing (mousedown, mouseup, mousemove)
            canvas.addEventListener('mousedown', (e) => {
                if (activeImageIndex === -1) return;
                
                // This event is only for drawing/erasing
                if (currentTool.startsWith('erase')) {
                    isDrawing = true; // Use isDrawing for continuous erase
                    if (currentTool === 'erase-dots') {
                        eraseDotsAtPosition(e);
                    } else if (currentTool === 'erase-image') {
                        eraseCanvasContentAtPosition(e);
                    }
                    draw();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                // This listener is only for eraser preview and drag-erasing
                
                // Update eraser preview position
                if (currentTool.startsWith('erase') && activeImageIndex !== -1) {
                    const rect = canvasContainer.getBoundingClientRect(); 
                    const previewLeft = e.clientX - rect.left + canvasContainer.scrollLeft;
                    const previewTop = e.clientY - rect.top + canvasContainer.scrollTop;

                    // NEW: Check which tool is active for radius
                    let currentEraserRadius = 0;
                    if (currentTool === 'erase-dots') {
                        currentEraserRadius = eraseDotsRadius;
                    } else if (currentTool === 'erase-image') {
                        currentEraserRadius = eraseImageRadius;
                    }
                    
                    // Use the correct radius and adjust position to be centered
                    eraserPreview.style.width = `${currentEraserRadius * 2}px`;
                    eraserPreview.style.height = `${currentEraserRadius * 2}px`;
                    eraserPreview.style.left = `${previewLeft - currentEraserRadius}px`;
                    eraserPreview.style.top = `${previewTop - currentEraserRadius}px`;
                }

                // Erase while dragging
                if (isDrawing && currentTool.startsWith('erase')) {
                    if (currentTool === 'erase-dots') {
                        eraseDotsAtPosition(e);
                    } else if (currentTool === 'erase-image') {
                        eraseCanvasContentAtPosition(e);
                    }
                    draw(); 
                }
            });

            canvas.addEventListener('mouseleave', () => {
                if (currentTool.startsWith('erase')) {
                    eraserPreview.classList.add('hidden');
                }
                isDrawing = false; // Stop drawing/erasing if mouse leaves canvas
            });

            canvas.addEventListener('mouseenter', (e) => {
                if (currentTool.startsWith('erase') && activeImageIndex !== -1) {
                    eraserPreview.classList.remove('hidden');
                }
            });

            // --- NEW: Pan Listeners on the CONTAINER ---
            canvasContainer.addEventListener('mousedown', (e) => {
                if (currentTool === 'pan') {
                    e.preventDefault();
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    canvasContainer.classList.remove('pan-cursor');
                    canvasContainer.classList.add('panning-cursor');
                }
            });

            canvasContainer.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    canvasContainer.classList.remove('panning-cursor');
                    canvasContainer.classList.add('pan-cursor');
                }
            });

            canvasContainer.addEventListener('mouseleave', () => {
                if (isPanning) {
                    isPanning = false;
                    canvasContainer.classList.remove('panning-cursor');
                    canvasContainer.classList.add('pan-cursor');
                }
            });
            
            canvasContainer.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    e.preventDefault();
                    const dx = e.clientX - lastPanX;
                    const dy = e.clientY - lastPanY;
                    
                    canvasContainer.scrollLeft -= dx;
                    canvasContainer.scrollTop -= dy;
                    
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                }
            });


            // Zoom Control Listeners
            zoomInButton.addEventListener('click', () => {
                if (activeImageIndex === -1) return;
                // Get center of viewport as fallback
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = rect.width / 2;
                const mouseY = rect.height / 2;
                zoomAtPoint(mouseX, mouseY, 1.25); // Zoom in by 25%
            });

            zoomOutButton.addEventListener('click', () => {
                if (activeImageIndex === -1) return;
                // Get center of viewport as fallback
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = rect.width / 2;
                const mouseY = rect.height / 2;
                zoomAtPoint(mouseX, mouseY, 0.8); // Zoom out by 20%
            });

            zoomResetButton.addEventListener('click', () => {
                if (activeImageIndex === -1) return; 
                zoomLevel = 1.0;
                updateZoom();
                // Reset scroll
                canvasContainer.scrollLeft = 0;
                canvasContainer.scrollTop = 0;
            });

            // Consolidated Zoom Function
            function zoomAtPoint(mouseX, mouseY, zoomFactor) {
                const oldScrollLeft = canvasContainer.scrollLeft;
                const oldScrollTop = canvasContainer.scrollTop;
                const oldZoom = zoomLevel;

                let newZoom = oldZoom * zoomFactor;
                newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom)); // Clamp zoom
                
                if (newZoom === oldZoom) return; // No change

                const imageX = (oldScrollLeft + mouseX) / oldZoom;
                const imageY = (oldScrollTop + mouseY) / oldZoom;

                zoomLevel = newZoom;
                updateZoom(); // This updates canvas display size

                const newScaledX = imageX * newZoom;
                const newScaledY = imageY * newZoom;

                canvasContainer.scrollLeft = newScaledX - mouseX;
                canvasContainer.scrollTop = newScaledY - mouseY;
            }

            canvasContainer.addEventListener('wheel', (e) => {
                if (activeImageIndex === -1) return;
                
                e.preventDefault(); // Prevent page scrolling

                // --- NEW: Zoom-to-Cursor Logic ---
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left; // Mouse pos relative to container
                const mouseY = e.clientY - rect.top;
                
                const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1; // 10% zoom in/out
                zoomAtPoint(mouseX, mouseY, zoomFactor);
                // --- End of New Zoom Logic ---

            }, { passive: false });


            // Slider Controls
            dotSizeSlider.addEventListener('input', (e) => {
                dotSize = parseInt(e.target.value, 10);
                dotSizeValue.textContent = dotSize;
                draw();
            });
            lineWidthSlider.addEventListener('input', (e) => {
                lineWidth = parseInt(e.target.value, 10);
                lineWidthValue.textContent = lineWidth;
                draw();
            });
            fontSizeSlider.addEventListener('input', (e) => {
                fontSize = parseInt(e.target.value, 10);
                fontSizeValue.textContent = fontSize;
                draw();
            });
            
            eraseDotsRadiusSlider.addEventListener('input', (e) => {
                eraseDotsRadius = parseInt(e.target.value, 10);
                eraseDotsRadiusValue.textContent = eraseDotsRadius;
                if (currentTool === 'erase-dots') {
                    eraserPreview.style.width = `${eraseDotsRadius * 2}px`;
                    eraserPreview.style.height = `${eraseDotsRadius * 2}px`;
                }
            });
            
            eraseImageRadiusSlider.addEventListener('input', (e) => {
                eraseImageRadius = parseInt(e.target.value, 10);
                eraseImageRadiusValue.textContent = eraseImageRadius;
                if (currentTool === 'erase-image') {
                    eraserPreview.style.width = `${eraseImageRadius * 2}px`;
                    eraserPreview.style.height = `${eraseImageRadius * 2}px`;
                }
            });
            spacingSlider.addEventListener('input', (e) => {
                dotSpacing = parseInt(e.target.value, 10);
                spacingValue.textContent = dotSpacing;
            });

            // Color Pickers
            dotColorPicker.addEventListener('input', (e) => {
                dotColor = e.target.value;
                draw();
            });
            lineColorPicker.addEventListener('input', (e) => {
                lineColor = e.target.value;
                draw();
            });

            // Action Buttons
            undoButton.addEventListener('click', () => {
                if (activeImageIndex === -1) return;
                const activeDots = allDots[activeImageIndex];
                if (activeDots.length > 0) {
                    activeDots.pop();
                    updateButtonStates();
                    draw();
                }
            });

            clearButton.addEventListener('click', () => {
                if (activeImageIndex === -1) return;
                modalTitle.textContent = 'Clear All Dots & Edits';
                modalMessage.textContent = 'Are you sure you want to clear all dots and image erasures for the CURRENT image? This action cannot be undone.';
                modalConfirm.textContent = 'Yes, Clear All';
                confirmModal.classList.remove('hidden');
            });

            // Modal button listeners
            modalCancel.addEventListener('click', () => {
                confirmModal.classList.add('hidden');
            });

            modalConfirm.addEventListener('click', () => {
                if (activeImageIndex === -1) return;

                // Clear dots for active image
                allDots[activeImageIndex] = [];
                
                // Reset active background image canvas
                const originalImg = originalBackgroundImages[activeImageIndex];
                const activeBgCanvas = currentBackgroundImages[activeImageIndex];
                
                if (originalImg && activeBgCanvas) {
                    const tempCtx = activeBgCanvas.getContext('2d');
                    tempCtx.clearRect(0, 0, activeBgCanvas.width, activeBgCanvas.height);
                    tempCtx.drawImage(originalImg, 0, 0);
                }
                
                // Reset zoom
                zoomLevel = 1.0;
                updateZoom();

                updateButtonStates();
                draw();

                confirmModal.classList.add('hidden');
            });
            
            // NEW: Add Ctrl+Z (or Cmd+Z) for Undo
            document.addEventListener('keydown', (e) => {
                // Check for Ctrl+Z or Cmd+Z
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault(); // Prevent browser's default undo
                    // Trigger the undo button's click event, if it's not disabled
                    if (!undoButton.disabled) {
                        undoButton.click();
                    }
                }
            });

            toggleImageButton.addEventListener('click', () => {
                if (activeImageIndex === -1) return;
                showImage = !showImage;
                toggleImageButton.textContent = showImage ? 'Hide Image' : 'Show Image';
                draw();
            });

            downloadButton.addEventListener('click', () => {
                if (activeImageIndex === -1) return;

                const activeBg = currentBackgroundImages[activeImageIndex];
                const activeDots = allDots[activeImageIndex];
                const originalImg = originalBackgroundImages[activeImageIndex];

                if (!originalImg) return; // Safety check

                // --- FINAL FIX: Read values DIRECTLY from controls at download time ---
                const currentLineWidth = parseInt(lineWidthSlider.value, 10);
                const currentDotSize = parseInt(dotSizeSlider.value, 10);
                const currentFontSize = parseInt(fontSizeSlider.value, 10);
                const currentDotColor = dotColorPicker.value;
                const currentLineColor = lineColorPicker.value;
                // --- End of Fix ---

                // 1. Create a new canvas in memory
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalImg.width;
                tempCanvas.height = originalImg.height;
                const tempCtx = tempCanvas.getContext('2d');

                // 2. Fill background with white (as requested by user for "blank")
                tempCtx.fillStyle = '#FFFFFF';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                // 3. Redraw everything onto this new canvas
                if (showImage && activeBg) {
                    tempCtx.drawImage(activeBg, 0, 0);
                }

                // 4. Draw lines (using the LOCAL variable)
                if (currentLineWidth > 0 && activeDots.length > 1) {
                    tempCtx.beginPath();
                    tempCtx.moveTo(activeDots[0].x, activeDots[0].y);
                    for (let i = 1; i < activeDots.length; i++) {
                        tempCtx.lineTo(activeDots[i].x, activeDots[i].y);
                    }
                    tempCtx.strokeStyle = currentLineColor;
                    tempCtx.lineWidth = currentLineWidth; // Uses LOCAL variable
                    tempCtx.stroke();
                }

                // 5. Draw dots and numbers (using LOCAL variables)
                tempCtx.font = `${currentFontSize}px Arial`;
                // tempCtx.textAlign = 'center'; // No longer default center
                tempCtx.textBaseline = 'middle';

                activeDots.forEach(dot => {
                    // Draw dot
                    tempCtx.beginPath();
                    tempCtx.arc(dot.x, dot.y, currentDotSize, 0, 2 * Math.PI);
                    tempCtx.fillStyle = '#FFFFFF';
                    tempCtx.fill();
                    tempCtx.strokeStyle = currentDotColor;
                    tempCtx.lineWidth = 1;
                    tempCtx.stroke();

                    // Draw number
                    tempCtx.fillStyle = currentDotColor;
                    tempCtx.textAlign = 'right'; // Align text to the right
                    // Offset number to the left of the dot
                    ctx.fillText(dot.number, dot.x - currentDotSize - 5, dot.y); // 5px gap
                });


                const link = document.createElement('a');
                // Use original file name if possible, otherwise index
                const fileName = imageSelector.options[activeImageIndex] ? imageSelector.options[activeImageIndex].text : `image-${activeImageIndex + 1}`;
                const baseName = fileName.substring(0, fileName.lastIndexOf('.')) || fileName;
                link.download = `dot-to-dot-${baseName}.png`;
                // 6. Generate the data URL from the NEW temporary canvas
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
            });
            
            // NEW Event Listener for "Download All"
            downloadAllButton.addEventListener('click', () => {
                if (originalBackgroundImages.length === 0) return;

                // --- Read values DIRECTLY from controls at download time ---
                const currentLineWidth = parseInt(lineWidthSlider.value, 10);
                const currentDotSize = parseInt(dotSizeSlider.value, 10);
                const currentFontSize = parseInt(fontSizeSlider.value, 10);
                const currentDotColor = dotColorPicker.value;
                const currentLineColor = lineColorPicker.value;

                // Loop through every loaded image
                for (let i = 0; i < originalBackgroundImages.length; i++) {
                    const activeBg = currentBackgroundImages[i];
                    const activeDots = allDots[i];
                    const originalImg = originalBackgroundImages[i];

                    if (!originalImg) continue; // Skip if this image failed to load

                    // 1. Create a new canvas in memory
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = originalImg.width;
                    tempCanvas.height = originalImg.height;
                    const tempCtx = tempCanvas.getContext('2d');

                    // 2. Fill background with white
                    tempCtx.fillStyle = '#FFFFFF';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                    // 3. Redraw background (respecting the toggle)
                    if (showImage && activeBg) {
                        tempCtx.drawImage(activeBg, 0, 0);
                    }

                    // 4. Draw lines
                    if (currentLineWidth > 0 && activeDots.length > 1) {
                        tempCtx.beginPath();
                        tempCtx.moveTo(activeDots[0].x, activeDots[0].y);
                        for (let j = 1; j < activeDots.length; j++) {
                            tempCtx.lineTo(activeDots[j].x, activeDots[j].y);
                        }
                        tempCtx.strokeStyle = currentLineColor;
                        tempCtx.lineWidth = currentLineWidth;
                        tempCtx.stroke();
                    }

                    // 5. Draw dots and numbers
                    tempCtx.font = `${currentFontSize}px Arial`;
                    tempCtx.textBaseline = 'middle';

                    activeDots.forEach(dot => {
                        tempCtx.beginPath();
                        tempCtx.arc(dot.x, dot.y, currentDotSize, 0, 2 * Math.PI);
                        tempCtx.fillStyle = '#FFFFFF';
                        tempCtx.fill();
                        tempCtx.strokeStyle = currentDotColor;
                        tempCtx.lineWidth = 1;
                        tempCtx.stroke();

                        tempCtx.fillStyle = currentDotColor;
                        tempCtx.textAlign = 'right';
                        tempCtx.fillText(dot.number, dot.x - currentDotSize - 5, dot.y);
                    });

                    // 6. Create link and trigger download
                    const link = document.createElement('a');
                    const fileName = imageSelector.options[i] ? imageSelector.options[i].text : `image-${i + 1}`;
                    const baseName = fileName.substring(0, fileName.lastIndexOf('.')) || fileName;
                    link.download = `dot-to-dot-${baseName}.png`;
                    link.href = tempCanvas.toDataURL('image/png');
                    link.click();
                }
            });

            // Initial state setup
            disableControls();
        });
    </script>
</body>
</html>

